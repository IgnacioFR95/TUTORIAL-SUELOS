
---
title: "**TUTORIAL PARA ELABORACIÓN DE MAPAS DE PROPIEDADES EDÁFICAS**"
author: "Ignacio Fernández Ruiz"
date: "23/5/2020"
output: html_document
---

<style>
p.caption {
  font-size: 0.8em;
}
</style>

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE
)
```

##### ** Te sugiero leer el documento "README" antes de comenzar con el tutorial**

___________________________________________________________________________________________


## **ÍNDICE**
    
###  [1.PREPARACIÓN DEL ENTORNO DE TRABAJO](#id1)

#### [1.1 Comprobación de versiones y paquetes](#id11)
###### [1.1.a Verificación de la versión de R](#id12a)
###### [1.1.b Verificación de la versión de RStudio](#id12b)
###### [1.1.c Verificación de los paquetes](#id12c)
###### [1.1.d Fin de las comprobaciones](#id12d)
#### [1.2 Cargando las librerías](#id11)

    
###  [2. CARGA DE LOS DATOS CRUDOS](#id1)
#### [2.1 Carga de datos crudos](#id11)
###### [2.2. Homogeneizar y limpiar los datos](#id12e)
   
### [2. PREPARACIÓN DEL ENTORNO DE TRABAJO](#id2)
#### [2.1 Generación del mapa base](#id21)
######  [2.1.a Generación del pol?gono](#id21a)
###### [2.1.b Generación de la malla](#id21b)
#### [2.2 Adaptación de los datos al mapa base](#id22)
   
### [3. NORMALIZACIÓN DE LAS VARIABLES](#id3)
#### [3.1 Metodologíaa de normalización de variables](#id31)
###### [3.1.a Histograma](#id31a)
###### [3.1.b Gráfico cuantil-cuantil](#id31b)
###### [3.1.c Test de shapiro](#id31c)
###### [3.1.d Modificación de los datos](#id31d)
#### [3.2 Normalización variable GLUCOSIDASA](#id32)
#### [3.3 Normalización variable FOSFATASA](#id33)
#### [3.4 Normalización variable NITR?GENO](#id34)
#### [3.5 Normalización variable F?SFORO](#id35)
#### [3.6 Normalización variable POTASIO](#id36)
#### [3.7 Normalización variable CARBONO](#id37)
#### [3.8 Normalización variable pH](#id38)
#### [3.9 Normalización variable ARENA](#id39)
#### [3.10 Normalización variable LIMO](#id310)
#### [3.11 Normalización variable ARCILLA](#id311)
   
### [4. GENERACI?N DE LA CARTOGRAF?A ED?FICA](#id4)
#### [4.1 Metodolog?a de cartograf?a ed?fica](#id41)
###### [4.1.a Funci?n "autokriging()"](#id41a)
###### [4.1.b Kriging manual](#id41b)
#### [4.2 Cartograf?a de variable GLUCOSIDASA](#id42)
###### [4.2.a Autokriging de Glucosidasa](#id42a)
###### [4.2.b Kriging manual de Glucosidasa](#id42b)
#### [4.3 Cartograf?a de variable FOSFATASA](#id43)
###### [4.3.a Autokriging de Fosfatasa](#id43a)
###### [4.3.b Kriging manual de Fosfatasa](#id43b)
#### [4.4 Cartograf?a de variable NITR?GENO](#id44)
###### [4.4.a Autokriging de Nitr?geno](#id44a)
###### [4.4.b Kriging manual de Nitr?geno](#id44b)
#### [4.5 Cartograf?a de variable F?SFORO](#id45)
###### [4.5.a Autokriging de F?sforo](#id45a)
###### [4.5.b Kriging manual de F?sforo](#id45b)
#### [4.6 Cartograf?a de variable POTASIO](#id46)
######  [4.6.aAutokriging de Potasio](#id46a)
######  [4.6.b Kriging manual de Potasio](#id46b)
#### [4.7 Cartograf?a de variable CARBONO](#id47)
###### [4.7.a Autokriging de Carbono](#id47a)
###### [4.7.b Kriging manual de Carbono](#id47b)
#### [C4.8 artograf?a de variable pH](#id48)
###### [4.8.a Autokriging de pH](#id48a)
###### [4.8.b Kriging manual de pH](#id48b)
#### [4.9 Cartograf?a de variable ARENA](#id49)
###### [4.9.a Autokriging de Arena](#id49a)
###### [4.9.b Kriging manual de Arena](#id49b)
#### [4.10 Cartograf?a de variable LIMO](#id410)
###### [4.10.a Autokriging de Limo](#id410a)
###### [4.10.b Kriging manual de Limo](#id410b)
#### [4.11 Cartograf?a de variable ARCILLA](#id411)
###### [4.11.a Autokriging de Arcilla](#id411a)
###### [4.11.b Kriging manual de Arcilla](#id411b)

___

## 1 PREPARACIÓN DEL ENTORNO DE TRABAJO<a name="id1"></a>

En primer lugar, comprobamos la versión de `R` utilizada y cargamos los paquetes necesarios para realizar los análisis

### 1.1 Comprobación de versiones y paquetes <a name="id12"></a>

#### 1.1.a Verificación de la versión de R:<a name="id12a"></a>

Con el siguiente código comprobamos que la versión de `R` sea igual o superior a la `3.6.0`.

El comando aplica la siguiente orden: "Si la versión de R es menor que la `3.6.0`, genera un mensaje de alerta donde especifique el mensaje" (En este caso, el mensaje elegido es un aviso de que la versión de `R` es antigua y se necesita actualizar).

~~~
if(getRversion() < "3.6.0") {stop("##########\nLa versión de R que posee está desactualizada\nPor favor, instale la última versión\n##########")}
~~~

#### 1.1.b Verificación de la versión de RStudio::<a name="id12b"></a>
Comprobamos que la versión de `RStudio` sea igual o superior a la `1.0.1`.

El comando aplica la siguiente orden: "Si la versión de RStudio es menor que la `3.6.0`, genera un mensaje de alerta donde especifique el mensaje". En este caso, el mensaje elegido es un aviso de que la versión de `RStudio` está desactualizada y se necesita actualizarse.

~~~
if(RStudio.Version()$version < "1.0.1"){stop("##########\nLa versión de RStudio que posee es antigua\nPor favor, instale la última versión\n##########")}
~~~

#### 1.1.c Verificación de los paquetes:<a name="id12c"></a>

Comprobamos si los paquetes que necesiaremos más adelante están instalados.

~~~
PaquetesNecesarios <- c("lattice","sp","gstat","maptools","spatstat","raster","automap")
installed_packages <- .packages(all.available = TRUE)
PaquetesNecesarios2 <- PaquetesNecesarios[!PaquetesNecesarios %in% installed_packages]
~~~

Y a continuación descargamos los paquetes faltantes desde `CRAN`: 

~~~
if(length(PaquetesNecesarios2) > 0){install.packages(PaquetesNecesarios2)}
stopifnot(all(c(PaquetesNecesarios) %in% .packages(all.available = TRUE)))
~~~

#### 1.1.d Fin de las comprobaciones:<a name="id12d"></a>

La función `rm()` elimina los objetos que no ncesitamos, en este caso se eliminarán los objetos que hemos utilizado para confirmar que los paquetes están instalados.

~~~
rm(PaquetesNecesarios, PaquetesNecesarios2, installed_packages)
~~~

### 1.2 Librerías<a name="id13"></a>

En el paso `1.2` ya hemos descargado los paquetes de `R` que necesitamos para hacer el tutorial. Ahora vamos a cargar las librerías. 

~~~
library(lattice)
library(sp)
library(gstat)
library(maptools)
library(spatstat)
library(raster)
library(automap)
~~~

###  2. CARGA DE LOS DATOS CRUDOS

### 2.1 Cargar los datos "crudos" o de origen <a name="id11"></a>
A continuación cargaremos los datos con los que vamos a trabajar.
En nuestro caso, hemos generado un archivo en formato `.txt` con los datos.

Para leer los datos usaremos la función `read.delim()`, indicaremos que los datos están separados por tabulaciones, que el símbolo decimal es la `,` y que nuestro archivo tiene encabezados. 

~~~
VariablesSuelo <- read.delim("data/Orusco_suelos.txt", sep="\t", dec=",", header=T)
load("data/AerialRoot.community.corregido.Rdata")
~~~

### 2.2 Homogeneizar y limpiar los datos:<a name="id12e"></a>

Para continuar trabajando debemos homogeneizar y limpiar los datos originales o crudos. En este caso, los datos ya están muy limpios, pero eliminaremos aquellas variables con las que no vamos a trabajar. No modificaremos nunca los datos originales.


En el objeto VariablesSuelo, renombramos el nombre de de la columna 11 y cambiamos `COD` por `codigo_muestra`

~~~
colnames(VariablesSuelo)[11] <- "codigo_muestra"
~~~

Eliminamos las columnas que no nos interesan para este tutorial en concreto, simplificando así el data frame:

~~~
VariablesSuelo$Fecha <- NULL
VariablesSuelo$COND <- NULL
VariablesSuelo$Altura.elipsoidal <- NULL
VariablesSuelo$id_suelo_raiz <- NULL
VariablesSuelo$Nº <- NULL
VariablesSuelo$Marco <- NULL
VariablesSuelo$ID_GPS <- NULL
~~~

### 2.3 Transformación de los datos originales a datos espaciales <a name="id14"></a>

Vamos a transformar los datos al tipo de datos `SpatialPointDataFrame`. 
Para ello, asignaremos al objeto un nuevo sistema de coordenadas y limitaremos el número de decimales que puedan tener los datos a 10.

Como estamos trabajando localmente, no necesitamos utilizar coordenadas globales. Dentro del  objeto `VariablesSuelo` vamos a utilizar unas coordenadas que son relativas al sitio de estudio. Las columnas con los valores de las coordenadas locales se llaman `Xlocal` y `Ylocal`. Es posible que otros data sets contengan coordenadas globales, no es ningún problema, simplemente depende del trabajo que estés realizando

La función `coordinates()` del paquete `sp` nos permite asignar coordenadas a un `data.frame` transformandolo en `SpatialPointDataFrame`. Para ello tenemos que indicale qué columnas son las que queremos que utilice como coordenadas, en este caso se llaman `Xlocal` y `Ylocal`. 

~~~
coordinates(VariablesSuelo) <- ~ Xlocal + Ylocal
~~~

Comprobamos que efectivamente el objeto `VariablesSuelo` es ahora un objeto de clase `SpatialPointsDataFrame`

~~~
class(VariablesSuelo)
~~~

Por ultimo, limitamos el número de decimales de los datos a 10, para evitar cifras excesivamente largas utilizando la función `options()`

~~~
options(digits=10)
~~~

## 4. PREPARACIÓN DE UN MAPA BASE<a name="id2"></a>

A continuación, vamos a generar un mapa al que denominamos "base" y sobre el cual vamos a dibujar el mapa de cada variable. Para ello necesitamos indicar el tamaño del área de estudio o plot, las coordenadas que poseen y el tamaño de malla que  utilizaremos para el posterior análisis mediante Kriging. 

En primer lugar vamos a crear un rectángulo con las dimensiones del área de estudio. En nuestro caso, hacemos un rectángulo porque la parcela tiene esa forma. Para definir el rectángulo usamos las cuatro esquinas de la parcela. 

Ya tenemos cargada una matriz denomin `esquinas.parcela` que contiene esos cuatro puntos. Los nombres de las columnas que contienen las coordnadas X y Y son `Xlocal` y `Ylocal`.

Utilizamos la función `Polygon()` para crear el polígono.
~~~
p1 <- Polygon(esquinas.parcela[,1:2])
~~~

Hacemos dos transformaciones: con la función `Polygons()` convertimos el poligono en un objeto de tipo espacial, y con la funcion `SpatialPolygons()` lo convertimos en un objeto de tipo `SpatialPolygons`

~~~
ps1 <- Polygons(list(p1),1)

sps1 <- SpatialPolygons(list(ps1))
~~~

Podemos consultar la clase del objeto `sps1` con la función `class()`

~~~
class(sps1)
~~~

A continuación dotamos al polígono que hemos creado de de una rejilla de 0.05 x 0.05 m. Utilizamos para ello la función `spsample()` y definimos el tamaños de la celda o rejilla con el argumento `cellsize`.
Además eliminamos todos los puntos que quedan fuera de los límites del rectángulo.

~~~
grid = spsample(VariablesSuelo, type = "regular", cellsize = c(0.05, 0.05))

pts1 <- as.data.frame(grid[!is.na(over(grid, sps1,))])
~~~
Ya tenemos la malla o rejilla lista. 

A continuación simplemente vamos a modificar el nombre de las coordenadas `X` e `Y` para indicar que son coordenadas locales.
~~~
names(pts1) <- c("Xlocal", "Ylocal")
~~~

A continuación indicamos con la función `coordinates()` que esas dos columnas son columnas de coordenadas y transformamos el objeto pts1 a un objeto de clase `SpatialPoints`

~~~
coordinates(pts1) <- c("Xlocal", "Ylocal")
pts1 <- SpatialPixelsDataFrame(as(pts1, "SpatialPoints"), data=as(pts1, "data.frame"), tolerance=0.077)
~~~

Podemos observar cómo quedaría gráficamente el objeto `pts1` con la función `plot()`

~~~
plot(pts1)
~~~

Por último, asignamos un sistema de coordenadas a la malla:

~~~
grid = spsample(VariablesSuelo, type = "regular", cellsize = c(0.05,0.05), proj4string = CRS("+proj=utm +ellps=WGS84 +datum=WGS84"))
~~~

## 5. NORMALIZACIÓN DE LAS VARIABLES<a name="id3"></a>

Una vez tenemos preparado el polígono y la rejilla donde "dibujaremos" los mapas, tenemos que hacer una exploración de los datos para ver si cumple con los requisitos de normalidad de los datos necesarios para realizar un Kriging.

El método de Kriging asume que los datos siguen una distribución normal. Lo que vamos a hacer es visualizar la distribución de los datos para ver si siguen una tendencia normal y realizar un Test de Shapiro para comprobar si la distribución de los datos se ajusta a una distribución normal.

### 5.1 Histograma:<a name="id31a"></a>
Se trata de una representación de una distribución de frecuencias. Para realizar este gráfico, utilizamos la función `hist()`

### 5.2 Gráfico cuantil-cuantil:<a name="id31b"></a>
También denominado QQplot permite comparar la distribución de nuestros datos con una distribución normal teórica. Si la distribución de nuestra variable es la misma que la distribución de comparación se obtendrá, aproximadamente, una línea recta. Si la distribución de nuestros datos se desvía sustancialmente de la linealidad, significa que la distribución de nuestros datos no es similar a la distribución normal. Para realizar este gráfico, utilizamos la función `qqnorm()` 

### 5.3 Test de Shapiro:<a name="id31c"></a>
Es un test estadístico para contrastar la normalidad de un conjunto de datos. La hipótesis nula es que la muestra de interés sigue una distribución normal. El test nos da un p-valor. Si el p-valor es superior a 0.05 (o al nivel de significancia alpha que determinemos), es decir, no significativo, no podemos rechazar la hipótesis nula. Si el p-valor es menor o igual a 0.05, podemos rechazar la hipótesis nula (la distribución de nuestros datos no es normal). En este tutorial hemos utilizado la función `shapiro.test()`

### 5.4 Transformación de los datos:<a name="id31d"></a>
En aquellos casos en que los datos no sigan una distribución normal, realizaremos transformaciones para ajustar la distribución de nuestros datos a una distribución normal. 


#### 5.5 Ejemplo de normalización de dos variables edáficas:<a name="id31d"></a>

HE LLEGADO CORRIGIENDO HASTA AQUí. 
HE LLEGADO CORRIGIENDO HASTA AQUí. 
HE LLEGADO CORRIGIENDO HASTA AQUí. 
Cuando sigas con el tutorial, fiajete que sea consistente con las correcciones que he hecho hasta aquí, me refiero al formato y el lenguaje.
Y mira lo que te dije en el email sobre elegir dos variables como ejemplo para los mapas. Se hace muy dificil de seguir todo esto taaaaaan largo. Y como tutorial no merece la pena que le gastes tanto tiempo.
HE LLEGADO CORRIGIENDO HASTA AQUí. 
HE LLEGADO CORRIGIENDO HASTA AQUí. 
HE LLEGADO CORRIGIENDO HASTA AQUí. 


### |3.2| Normalización variable GLUCOSIDASA<a name="id32"></a>

~~~
hist(VariablesSuelo$GLUC)
qqnorm(VariablesSuelo$GLUC) 
shapiro.test((VariablesSuelo$GLUC))
~~~

Esta variable no muestra un patr?n normalizado y su p-valor es muy bajo. **No es v?lida**.

~~~
hist(log(VariablesSuelo$GLUC)) 
qqnorm(log(VariablesSuelo$GLUC))
shapiro.test(log(VariablesSuelo$GLUC)) 
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos el logaritmo de la glucosidasa para el mapeado --> LOG(GLUC).**

### |3.3| Normalización variable FOSFATASA<a name="id33"></a>

~~~
hist(VariablesSuelo$FOSF)
qqnorm(VariablesSuelo$FOSF) 
shapiro.test((VariablesSuelo$FOSF))
~~~

Esta variable no muestra un patr?n normalizado y su p-valor es muy bajo. **No es v?lida**.

~~~
hist(log(VariablesSuelo$FOSF)) 
qqnorm(log(VariablesSuelo$FOSF))
shapiro.test(log(VariablesSuelo$FOSF)) 
~~~

Esta variable no muestra un patr?n normalizado y su p-valor es muy bajo. **No es v?lida**.

~~~
hist(log(VariablesSuelo$FOSF+1)) 
qqnorm(log(VariablesSuelo$FOSF+1))
shapiro.test(log(VariablesSuelo$FOSF+1)) 
~~~
Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos el logaritmo de la Fosfatasa para el mapeado --> LOG(FOSF).**


### |3.4| Normalización variable NITR?GENO<a name="id34"></a>

~~~
hist(VariablesSuelo$N)
qqnorm(VariablesSuelo$N) 
shapiro.test((VariablesSuelo$N))
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos directamente el valor Nitr?geno para el mapeado --> (N).**


### |3.5| Normalización variable F?SFORO<a name="id35"></a>

~~~
hist(VariablesSuelo$P)
qqnorm(VariablesSuelo$P) 
shapiro.test((VariablesSuelo$P))
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos directamente el valor F?sforo para el mapeado --> (P).**


### |3.6| Normalización variable POTASIO<a name="id36"></a>

~~~
hist(VariablesSuelo$K)
qqnorm(VariablesSuelo$K) 
shapiro.test((VariablesSuelo$K))
~~~

Esta variable no muestra un patr?n normalizado y su p-valor es muy bajo. **No es v?lida**.

~~~
hist(log(VariablesSuelo$K)) 
qqnorm(log(VariablesSuelo$K))
shapiro.test(log(VariablesSuelo$K)) 
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos el logaritmo del Potasio para el mapeado --> LOG(K).**



### |3.7| Normalización variable CARBONO<a name="id37"></a>

~~~
hist(VariablesSuelo$C)
qqnorm(VariablesSuelo$C) 
shapiro.test((VariablesSuelo$C))
~~~

Esta variable no muestra un patr?n normalizado y su p-valor es muy bajo. **No es v?lida**.

~~~
hist(log(VariablesSuelo$C)) 
qqnorm(log(VariablesSuelo$C))
shapiro.test(log(VariablesSuelo$C)) 
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos el logaritmo del Carbono para el mapeado --> LOG(C).**


### |3.8| Normalización variable pH ECHARLE UN OJO<a name="id38"></a>

~~~
hist(VariablesSuelo$pH)
qqnorm(VariablesSuelo$pH) 
shapiro.test((VariablesSuelo$pH))
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos directamente el valor pH para el mapeado --> (pH).**


### |3.9| Normalización variable ARENA<a name="id39"></a>

~~~
hist(VariablesSuelo$Arena)
qqnorm(VariablesSuelo$Arena) 
shapiro.test((VariablesSuelo$Arena))
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos directamente el valor Arena para el mapeado --> (Arena).**


### |3.10| Normalización variable LIMO<a name="id310"></a>

~~~
hist(VariablesSuelo$Limo)
qqnorm(VariablesSuelo$Limo) 
shapiro.test((VariablesSuelo$Limo))
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos directamente el valor Limo para el mapeado  --> (Limo).**


### |3.11| Normalización variable ARCILLA ECHARLE UN OJO<a name="id311"></a>

~~~
hist(VariablesSuelo$Arcilla)
qqnorm(VariablesSuelo$Arcilla) 
shapiro.test((VariablesSuelo$Arcilla))
~~~

Esta variable no muestra un patr?n normalizado y su p-valor es muy bajo. **No es v?lida**.

~~~
hist(log(VariablesSuelo$Arcilla)) 
qqnorm(log(VariablesSuelo$Arcilla))
shapiro.test(log(VariablesSuelo$Arcilla)) 
~~~

Esta variable no muestra un patr?n normalizado y su p-valor es muy bajo. **No es v?lida**.

~~~
hist(log(VariablesSuelo$Arcilla)+1) 
qqnorm(log(VariablesSuelo$Arcilla)+1)
shapiro.test(log(VariablesSuelo$Arcilla)+1) 
~~~

Esta variable muestra un patr?n normalizado y su p-valor es aceptable. **Es v?lida**.

##### **Utilizaremos el logaritmo del Arcilla para el mapeado --> LOG((Arcilla)+1).**



## |4| ELABORACIÓN DE LOS MAPAS DE SUELOS <a name="id4"></a>

En esta ?ltima fase, vamos a realizar los mapas de cada una de las variables utilizando el m?todo de estimaci?n geoestad?stico denominado kriging. Esta  t?cnica de interpolaci?n, utiliza un modelo de variograma para poder estimar  el resto de puntos intermedios donde no se tiene un dato real recogido directamente del campo.

### |4.1| Metodolog?a de cartograf?a ed?fica<a name="id41"></a>
Existen dos formas para la realizaci?n de cartograf?a ed?fica utilizando el m?todo de kriaje:
#### |4.1.a| Autom?ticamente con la funci?n *"autokriging()"*:<a name="id41a"></a>
El propio programa estad?stico R, realiza los c?lculos y elige el sistema con una mejor relaci?n con la realidad. Sus estimaciones aunque bastante precisas, suelen incurrir en cierto error, este puede ser asumible dependiendo del grado de precisi?n que desee el estudio.

#### |4.1.b| Kriging manual:<a name="id41b"></a>
Ejecutamos cinco modelos matem?ticos con y sin tendencia y observamos cual se adapta mejor a nuestra serie de datos, posteriormente, se genera un krigeado partiendo de ese modelo y se visualiza c?mo quedar?a gr?ficamente.  

Antes de realizar el kriging manual y, para mejorar la precisi?n del kriging, necesitamos observar a qu? modelo matem?tico concreto se ajusta el variograma con mayor exactitud.  Esto, podemos observarlo mediante el comando "autofitVariogram" seguido de los diferentes modelos estudiados: **Exponencial (Exp)**, **Esf?rico (Sph)**, **Gausiano(Gau)** **Lineal(Lin)** y la **parametrizaci?n de Stein (Ste)**.  

Ejemplo:

~~~
autofitVariogram(log(GLUC) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
~~~

Esta l?nea de c?digo nos informar? c?mo se adapta el variograma de datos de la Glucosidasa al modelo exponencial sin ninguna tendencia. Este comando nos dar? como salida un valor de semivarianza, cuanto m?s cercano est? este valor a 0, mayor se ajustar? los datos a la modelizaci?n Exponencial (en este caso).  

Para procesar todos los modelos a la vez, vamos a crear una matriz (una tabla) vac?a donde poner los resultados de semivarianza sin tendencia o con ella (utilizando ***Xlocal*** como valores de tendencia) de los 5 modelos estudiados. De esta forma, podremos observar qu? valor de semivarianza es menor (es decir, a qu? modelo se ajustan mejor los datos) y utilizar ese modelo matem?tico para producir la cartograf?a mediante el kriging.  

### |4.2| Cartograf?a de la variable CLUCOSIDASA<a name="id42"></a>
#### |4.2.a|Autokriging de Glucosidasa:<a name="id42a"></a>
Autokriging sin tendencia:

~~~
Autok.GLUC.ST <- autoKrige(log(GLUC) ~ 1, VariablesSuelo, pts1 )
~~~

# Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.GLUC.ST)
~~~

Autokriging con tendencia:

~~~
Autok.GLUC.CT <- autoKrige(log(GLUC) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.GLUC.CT)
~~~

#### |4.2.b| Kriging manual de Glucosidasa:<a name="id42b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo:

Le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente".*

~~~
MatrizGLUC <- matrix(NA,2,5)
colnames(MatrizGLUC) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizGLUC) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo:  
Le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.


Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizGLUC[1,1] <- autofitVariogram(log(GLUC) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizGLUC[1,2] <- autofitVariogram(log(GLUC) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizGLUC[1,3] <- autofitVariogram(log(GLUC)  ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizGLUC[1,4] <- autofitVariogram(log(GLUC)  ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizGLUC[1,5] <- autofitVariogram(log(GLUC)  ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizGLUC[2,1] <- autofitVariogram(log(GLUC)  ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizGLUC[2,2] <- autofitVariogram(log(GLUC)  ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizGLUC[2,3] <- autofitVariogram(log(GLUC)  ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizGLUC[2,4] <- autofitVariogram(log(GLUC) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizGLUC[2,5] <- autofitVariogram(log(GLUC)  ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima.

Le decimos al programa "Dime qu? coordenada de la matriz tiene un valor menor".

~~~
which((MatrizGLUC) == min(MatrizGLUC), arr.ind=TRUE)
~~~


En este caso nos dice que ***"STE CON TENDENCIA"*** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo *"ste"* con tendencia:

~~~
v.fitGLUCsteCT = autofitVariogram(log(GLUC) ~ Xlocal, VariablesSuelo, model = c("Ste"))$var_model
~~~

A continuaci?n podemos realizar el kriaje de la Glucosidasa:

Con esta funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de VariablesSuelo adaptados al modelo* ***"Ste"*** *con tendencia en la malla* ***pts1"***.

~~~
GLUC.mapa <- krige(log(GLUC) ~  Xlocal, VariablesSuelo, pts1, v.fitGLUCsteCT)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de glucosidasa. La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***GLUC.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"GLUCOSIDASA"*** *.*

~~~
plot(GLUC.mapa, main= "GLUCOSIDASA") 
~~~


### |4.3| Cartograf?a de la variable FOSFATASA<a name="id43"></a>
#### |4.3.a| Autokriging de Fosfatasa:<a name="id43a"></a>
Autokriging sin tendencia:

~~~
Autok.FOSF.ST <- autoKrige(log(FOSF+1) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.FOSF.ST)
~~~

Autokriging con tendencia:

~~~
Autok.FOSF.CT <- autoKrige(log(FOSF+1) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:
~~~
plot(Autok.FOSF.CT)
~~~

#### |4.3.b| Kriging manual de Fosfatasa:<a name="id43b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo. Le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente".*

~~~
MatrizFOSF <- matrix(NA,2,5)
colnames(MatrizFOSF) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizFOSF) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo:
Le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizFOSF[1,1] <- autofitVariogram(log(FOSF+1) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizFOSF[1,2] <- autofitVariogram(log(FOSF+1) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizFOSF[1,3] <- autofitVariogram(log(FOSF+1)  ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizFOSF[1,4] <- autofitVariogram(log(FOSF+1)  ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizFOSF[1,5] <- autofitVariogram(log(FOSF+1)  ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos ***Xlocal*** como tendencia):

~~~
MatrizFOSF[2,1] <- autofitVariogram(log(FOSF+1)  ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizFOSF[2,2] <- autofitVariogram(log(FOSF+1)  ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizFOSF[2,3] <- autofitVariogram(log(FOSF+1)  ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizFOSF[2,4] <- autofitVariogram(log(FOSF+1)  ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizFOSF[2,5] <- autofitVariogram(log(FOSF+1)  ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima.  

El siguiente comando le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizFOSF) == min(MatrizFOSF), arr.ind=TRUE)
~~~

En este caso nos dice que ***"GAU SIN TENDENCIA"*** es el mejor, as? que ser? el  utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo *"Gau" sin tendencia*:

~~~
v.fitFOSFgauST = autofitVariogram(log(FOSF+1) ~ 1, VariablesSuelo, model = c("Gau"))$var_model
~~~

A continuaci?n podemos realizar el kriaje de la fosfatasa:  

Con esta funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***"VariablesSuelo"*** *adaptados al modelo* ***"Gau" sin tendencia*** *en la malla pts1".*

~~~
FOSF.mapa <- krige(log(FOSF+1) ~  1, VariablesSuelo, pts1, v.fitFOSFgauST)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de fosfatasa:  

La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***FOSF.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"FOSFATASA"*** *.*

~~~
plot(FOSF.mapa, main= "FOSFATASA")
~~~


### |4.4| Cartograf?a de la variable NITR?GENO<a name="id44"></a>
#### |4.4.a| Autokriging de Nitr?geno:<a name="id44a"></a>
Autokriging sin tendencia:

~~~
Autok.N.ST <- autoKrige((N) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.N.ST)
~~~

Autokriging con tendencia:

~~~
Autok.N.CT <- autoKrige((N) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.N.CT)
~~~

#### |4.4.b| Kriging manual de Nitr?geno:<a name="id44b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo, le decimos al programa: *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizN <- matrix(NA,2,5)
colnames(MatrizN) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizN) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo:
Le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizN[1,1] <- autofitVariogram((N) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizN[1,2] <- autofitVariogram((N) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizN[1,3] <- autofitVariogram((N)  ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizN[1,4] <- autofitVariogram((N)  ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizN[1,5] <- autofitVariogram((N)  ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizN[2,1] <- autofitVariogram((N)  ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizN[2,2] <- autofitVariogram((N)  ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizN[2,3] <- autofitVariogram((N)  ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizN[2,4] <- autofitVariogram((N)  ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizN[2,5] <- autofitVariogram((N)  ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima.

El siguiente comando le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor":*

~~~
which((MatrizN) == min(MatrizN), arr.ind=TRUE)
~~~

En este caso nos dice que ***"LIN CON TENDENCIA"*** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo ***"Lin" con tendencia***:

~~~
v.fitNlinCT = autofitVariogram((N) ~ 1, VariablesSuelo, model = c("Lin"))$var_model
~~~

A continuaci?n podemos realizar el kriaje del Nitr?geno:
Con esta funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Lin" con tendencia*** *en la malla* ***pts1"*** *.*

~~~
N.mapa <- krige((N) ~  1, VariablesSuelo, pts1, v.fitNlinCT)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de Nitr?geno:

La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***N.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"NITR?GENO"*** *.*

~~~
plot(N.mapa, main= "NITR?GENO") 
~~~



### |4.5| Cartograf?a de la variable f?sforo<a name="id45"></a>
#### |4.5.a| Autokriging de F?sforo:<a name="id45a"></a>

Autokriging sin tendencia:

~~~
Autok.P.ST <- autoKrige((P) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.P.ST)
~~~

Autokriging con tendencia:

~~~
Autok.P.CT <- autoKrige((P) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.P.CT)
~~~

#### |4.5.a| Kriging manual de F?sforo:<a name="id45b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo, le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizP <- matrix(NA,2,5)
colnames(MatrizP) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizP) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo:

Le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizP[1,1] <- autofitVariogram((P) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizP[1,2] <- autofitVariogram((P) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizP[1,3] <- autofitVariogram((P) ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizP[1,4] <- autofitVariogram((P) ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizP[1,5] <- autofitVariogram((P) ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizP[2,1] <- autofitVariogram((P) ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizP[2,2] <- autofitVariogram((P) ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizP[2,3] <- autofitVariogram((P) ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizP[2,4] <- autofitVariogram((P) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizP[2,5] <- autofitVariogram((P) ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima:

El siguiente comando le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizP) == min(MatrizP), arr.ind=TRUE)
~~~

En este caso nos dice que **"GAU CON TENDENCIA"** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo **"Gau" con tendencia**:

~~~
v.fitPgauCT = autofitVariogram((P) ~ Xlocal, VariablesSuelo, model = c("Gau"))$var_model
~~~

A continuaci?n podemos realizar el kriaje del F?sforo.

Con esta funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Gau" con tendencia*** *en la malla* ***pts1"*** *.*

~~~
P.mapa <- krige((P) ~  Xlocal, VariablesSuelo, pts1, v.fitPgauCT)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de F?sforo, la siguiente funci?n expresa *"Genera un gr?fico del objeto* ***P.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"F?SFORO"*** *.*

~~~
plot(P.mapa, main= "F?SFORO")
~~~

### |4.6| Cartograf?a de la variable POTASIO<a name="id46"></a>
#### |4.6.a| Autokriging de Potasio:<a name="id46a"></a>
Autokriging sin tendencia:

~~~
Autok.K.ST <- autoKrige(log(K) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.K.ST)
~~~

Autokriging con tendencia:

~~~
Autok.K.CT <- autoKrige(log(K) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.K.CT)
~~~

#### |4.6.a| Kriging manual de Potasio:<a name="id46b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo, le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizK <- matrix(NA,2,5)
colnames(MatrizK) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizK) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo:
Le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizK[1,1] <- autofitVariogram(log(K) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizK[1,2] <- autofitVariogram(log(K) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizK[1,3] <- autofitVariogram(log(K)  ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizK[1,4] <- autofitVariogram(log(K)  ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizK[1,5] <- autofitVariogram(log(K)  ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizK[2,1] <- autofitVariogram(log(K)  ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizK[2,2] <- autofitVariogram(log(K)  ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizK[2,3] <- autofitVariogram(log(K)  ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizK[2,4] <- autofitVariogram(log(K) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizK[2,5] <- autofitVariogram(log(K)  ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima. Con el siguiente comando le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizK) == min(MatrizK), arr.ind=TRUE)
~~~

En este caso nos dice que **"LIN CON TENDENCIA"** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo **"Lin" con tendencia**:

~~~
v.fitKlinCT = autofitVariogram(log(K) ~ Xlocal, VariablesSuelo, model = c("Lin"))$var_model
~~~

A continuaci?n podemos realizar el kriaje del Potasio.

Con esta funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Lin" con tendencia*** *en la malla* ***pts1"*** *.*

~~~
K.mapa <- krige(log(K) ~  Xlocal, VariablesSuelo, pts1, v.fitKlinCT)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de Potasio. La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***K.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"POTASIO"****.*

~~~
plot(K.mapa, main= "POTASIO") 
~~~


### |4.7| Cartograf?a de la variable CARBONO<a name="id47"></a>
#### |4.7.a| Autokriging de Carbono:<a name="id47a"></a>

Autokriging sin tendencia:

~~~
Autok.C.ST <- autoKrige(log(C) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.C.ST)
~~~

Autokriging con tendencia:

~~~
Autok.C.CT <- autoKrige(log(C) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.C.CT)
~~~

#### |4.7.b| Kriging manual de Carbono:<a name="id47b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo, le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizC <- matrix(NA,2,5)
colnames(MatrizC) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizC) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo, le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia*". Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizC[1,1] <- autofitVariogram(log(C) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizC[1,2] <- autofitVariogram(log(C) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizC[1,3] <- autofitVariogram(log(C)  ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizC[1,4] <- autofitVariogram(log(C)  ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizC[1,5] <- autofitVariogram(log(C)  ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizC[2,1] <- autofitVariogram(log(C)  ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizC[2,2] <- autofitVariogram(log(C)  ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizC[2,3] <- autofitVariogram(log(C)  ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizC[2,4] <- autofitVariogram(log(C) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizC[2,5] <- autofitVariogram(log(C)  ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima.

El siguiente comando le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizC) == min(MatrizC), arr.ind=TRUE)
~~~

En este caso nos dice que **"GAU CON TENDENCIA"** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo **"Gau" con tendencia**:

~~~
v.fitCgauCT = autofitVariogram(log(C) ~ Xlocal, VariablesSuelo, model = c("Gau"))$var_model
~~~

A continuaci?n podemos realizar el kriaje del Carbono.

Con esta funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Gau" con tendencia*** *en la malla* ***pts1*** *".*

~~~
C.mapa <- krige(log(C) ~  Xlocal, VariablesSuelo, pts1, v.fitCgauCT)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de Carbono:

La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***C.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"CARBONO"*** *.*

~~~
plot(C.mapa, main= "CARBONO")
~~~

### |4.8| Cartograf?a de la variable pH<a name="id48"></a>
#### |4.8.a| Autokriging de pH:<a name="id48a"></a>

Autokriging sin tendencia:

~~~
Autok.pH.ST <- autoKrige((pH) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.pH.ST)
~~~

Autokriging con tendencia:

~~~
Autok.pH.CT <- autoKrige((pH) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.pH.CT)
~~~


#### |4.8.b| Kriging manual de pH:<a name="id48b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo:

Le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizpH <- matrix(NA,2,5)
colnames(MatrizpH) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizpH) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo:

Le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.  

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizpH[1,1] <- autofitVariogram((pH) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizpH[1,2] <- autofitVariogram((pH) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizpH[1,3] <- autofitVariogram((pH) ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizpH[1,4] <- autofitVariogram((pH) ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizpH[1,5] <- autofitVariogram((pH) ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizpH[2,1] <- autofitVariogram((pH) ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizpH[2,2] <- autofitVariogram((pH) ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizpH[2,3] <- autofitVariogram((pH) ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizpH[2,4] <- autofitVariogram((pH) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizpH[2,5] <- autofitVariogram((pH) ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima, con el siguiente comando le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizpH) == min(MatrizpH), arr.ind=TRUE)
~~~

En este caso nos dice que **"STE SIN TENDENCIA"** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo **"Ste" sin tendencia**:

~~~
v.fitpHsteST = autofitVariogram((pH) ~ 1, VariablesSuelo, model = c("Ste"))$var_model
~~~

A continuaci?n podemos realizar el kriaje del pH, con la siguiente funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Ste" sin tendencia*** *en la malla* ***pts1*** *".*

~~~
pH.mapa <- krige((pH) ~  1, VariablesSuelo, pts1, v.fitpHsteST)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de pH. Con la siguiente funci?n expresamos lo siguiente: *"Genera un gr?fico del objeto* ***pH.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"pH"*** *.*

~~~
plot(pH.mapa, main= "pH") 
~~~


### |4.9| Generaci?n de la variable ARENA<a name="id49"></a>
#### |4.9.a| Autokriging de Arena:<a name="id49a"></a>

Autokriging sin tendencia:

~~~
Autok.Arena.ST <- autoKrige((Arena) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.Arena.ST)
~~~

Autokriging con tendencia:

~~~
Autok.Arena.CT <- autoKrige((Arena) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.Arena.CT)
~~~

#### |4.9.b| Kriging manual de Arena:<a name="id49b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo, Le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizArena <- matrix(NA,2,5)
colnames(MatrizArena) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizArena) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo, con el siguiente c?digo le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizArena[1,1] <- autofitVariogram((Arena) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizArena[1,2] <- autofitVariogram((Arena) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizArena[1,3] <- autofitVariogram((Arena)  ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizArena[1,4] <- autofitVariogram((Arena)  ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizArena[1,5] <- autofitVariogram((Arena)  ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizArena[2,1] <- autofitVariogram((Arena)  ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizArena[2,2] <- autofitVariogram((Arena)  ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizArena[2,3] <- autofitVariogram((Arena)  ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizArena[2,4] <- autofitVariogram((Arena) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizArena[2,5] <- autofitVariogram((Arena)  ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima, para ello, le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizArena) == min(MatrizArena), arr.ind=TRUE)
~~~

En este caso nos dice que **"STE SIN TENDENCIA"** es el mejor, as? que ser? el utilizado.Realizamos un autofitting de nuestros datos adapt?ndolo al modelo **"Ste" sin tendencia**:

~~~
v.fitArenasteST = autofitVariogram((Arena) ~ 1, VariablesSuelo, model = c("Ste"))$var_model
~~~

A continuaci?n podemos realizar el kriaje de la Arena. Con la siguiente funci?n, pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Ste" sin tendencia*** *en la malla* ***pts1*** *".*

~~~
Arena.mapa <- krige((Arena) ~  1, VariablesSuelo, pts1, v.fitArenasteST)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de Arena. La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***Arena.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"CONTENIDO EN ARENAS"*** *.*

~~~
plot(Arena.mapa, main= "CONTENIDO EN ARENAS")
~~~


### |4.10| Generaci?n de la variable LIMO<a name="id410"></a>
#### |4.10.a|  Autokriging de Limo:<a name="id410a"></a>
Autokriging sin tendencia:

~~~
Autok.Limo.ST <- autoKrige((Limo) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.Limo.ST)
~~~

Autokriging con tendencia:

~~~
Autok.Limo.CT <- autoKrige((Limo) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.Limo.CT)
~~~



#### |4.10.b| Kriging manual de Limo:<a name="id410b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo, le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizLimo <- matrix(NA,2,5)
colnames(MatrizLimo) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizLimo) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo:

Le decimos al programa *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizLimo[1,1] <- autofitVariogram((Limo) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizLimo[1,2] <- autofitVariogram((Limo) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizLimo[1,3] <- autofitVariogram((Limo) ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizLimo[1,4] <- autofitVariogram((Limo) ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizLimo[1,5] <- autofitVariogram((Limo) ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizLimo[2,1] <- autofitVariogram((Limo) ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizLimo[2,2] <- autofitVariogram((Limo) ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizLimo[2,3] <- autofitVariogram((Limo) ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizLimo[2,4] <- autofitVariogram((Limo) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizLimo[2,5] <- autofitVariogram((Limo) ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor, con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima, con ?l le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizLimo) == min(MatrizLimo), arr.ind=TRUE)
~~~

En este caso nos dice que **"STE SIN TENDENCIA"** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo **"Ste" sin tendencia**:

~~~
v.fitLimosteST = autofitVariogram((Limo) ~ 1, VariablesSuelo, model = c("Ste"))$var_model
~~~

A continuaci?n podemos realizar el kriaje de la variable Limos. Con esta funci?n pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Ste" sin tendencia*** *en la malla* ***pts1*** *".*

~~~
Limo.mapa <- krige((Limo) ~  1, VariablesSuelo, pts1, v.fitLimosteST)
~~~

Por ?tlimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de Limos. La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***Limo.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"CONTENIDO EN LIMO"*** *.*

~~~
plot(Limo.mapa, main= "CONTENIDO EN LIMO") 
~~~


### |4.11| Cartograf?a de la variable ARCILLA<a name="id411"></a>
#### |4.11.a| Autokriging de Arcilla:<a name="id411a"></a>

Autokriging sin tendencia:

~~~
Autok.Arcilla.ST <- autoKrige(log(Arcilla+1) ~ 1, VariablesSuelo, pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica sin tendencia:

~~~
plot(Autok.Arcilla.ST)
~~~

Autokriging con tendencia:

~~~
Autok.Arcilla.CT <- autoKrige(log(Arcilla+1) ~ Xlocal, VariablesSuelo, new_data=pts1 )
~~~

Visualizamos como ser?a la representaci?n gr?fica con tendencia:

~~~
plot(Autok.Arcilla.CT)
~~~


#### |4.11.b| Kriging manual de Arcillas:<a name="id411b"></a>

Generamos una matriz donde exponer las semivarianzas de cada modelo, le decimos al programa *"genera una matriz de 2x5 y nombra las columnas y las filas con los nombres de los modelos y la tendencia respectivamente"*.

~~~
MatrizArcilla <- matrix(NA,2,5)
colnames(MatrizArcilla) <- c("Exponencial","Esferico","Gausiano","Lineal","Ste")
rownames(MatrizArcilla) <- c("Sin tendencia", "Con tendencia")
~~~

Rellenamos con los datos de cada modelo, para ello le decimos  al programa con la siguiente l?nea de c?digo *"rellena la matriz generada con la semivarianza de cada modelo matem?tico y con o sin tendencia"*. Se debe asegurar de introducir los datos en el mismo orden que hemos facilitado a la matriz en el anterior paso.

Sin tendencia (Ponemos un 1, para indicar que no hay tendencia):

~~~
MatrizArcilla[1,1] <- autofitVariogram(log(Arcilla+1) ~ 1, VariablesSuelo, model = c("Exp"))$sserr
MatrizArcilla[1,2] <- autofitVariogram(log(Arcilla+1) ~ 1, VariablesSuelo, model = c("Sph"))$sserr
MatrizArcilla[1,3] <- autofitVariogram(log(Arcilla+1) ~ 1, VariablesSuelo, model = c("Gau"))$sserr
MatrizArcilla[1,4] <- autofitVariogram(log(Arcilla+1) ~ 1, VariablesSuelo, model = c("Lin"))$sserr
MatrizArcilla[1,5] <- autofitVariogram(log(Arcilla+1) ~ 1, VariablesSuelo, model = c("Ste"))$sserr
~~~

Con tendencia (Utilizamos Xlocal como tendencia):

~~~
MatrizArcilla[2,1] <- autofitVariogram(log(Arcilla+1) ~ Xlocal, VariablesSuelo,model = c("Exp"))$sserr
MatrizArcilla[2,2] <- autofitVariogram(log(Arcilla+1) ~ Xlocal, VariablesSuelo,model = c("Sph"))$sserr
MatrizArcilla[2,3] <- autofitVariogram(log(Arcilla+1) ~ Xlocal, VariablesSuelo,model = c("Gau"))$sserr
MatrizArcilla[2,4] <- autofitVariogram(log(Arcilla+1) ~ Xlocal, VariablesSuelo,model = c("Lin"))$sserr
MatrizArcilla[2,5] <- autofitVariogram(log(Arcilla+1) ~ Xlocal, VariablesSuelo,model = c("Ste"))$sserr
~~~

El modelo que se ajuste mejor ser? el que tenga un valor de semivarianza menor. Con el siguiente comando sabremos qu? modelo nos aporta la semivarianza m?nima, con el siguiente comando le decimos al programa *"Dime qu? coordenada de la matriz tiene un valor menor"*.

~~~
which((MatrizArcilla) == min(MatrizArcilla), arr.ind=TRUE)
~~~

En este caso nos dice que **"LIN CON TENDENCIA"** es el mejor, as? que ser? el utilizado. Realizamos un autofitting de nuestros datos adapt?ndolo al modelo **"Lin" con tendencia**:

~~~
v.fitArcillalinCT = autofitVariogram(log(Arcilla+1) ~ Xlocal, VariablesSuelo, model = c("Lin"))$var_model
~~~

A continuaci?n podemos realizar el kriaje de las arcillas, con esta funci?n, pedimos al programa *"Genera un objeto que sea el fruto del kriaje de los datos de* ***VariablesSuelo*** *adaptados al modelo* ***"Lin" con tendencia*** *en la malla* ***pts1*** *".*

~~~
Arcilla.mapa <- krige(log(Arcilla+1) ~  Xlocal, VariablesSuelo, pts1, v.fitArcillalinCT)
~~~

Por ?ltimo, observaremos el resultado gr?ficamente, dando como fruto un mapa de la zona en el que se observan las concentraciones de Arcilla. La siguiente funci?n expresa *"Genera un gr?fico del objeto* ***Arcilla.mapa*** *(que es el resultado del kriaje de los datos) y cuyo t?tulo sea* ***"CONTENIDO EN ARCILLA"*** *.*

~~~
plot(Arcilla.mapa, main= "CONTENIDO EN ARCILLAS")
~~~

___



? ? ? ? ?    ? ? ? ? ?    ? ?